<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />

  <title>Complete Intro to React</title>
  <meta name="description" content="A Complete Intro to React, as taught for FrontendMasters.com
">
  <meta name="keywords" content="" />

  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="shortcut icon" href="/favicon.ico">

  <link rel="stylesheet" type="text/css" href="/css/main-9048261e4d.css" />
</head>
<body class="archive-template paged">

  <header class="main-header">
    <div class="vertical">
      <div class="main-header-content">
        <h1 class="page-title">
          <a href="/">Complete Intro to React</a>
        </h1>
      </div>
    </div>
  </header>

  <main id="content" class="content" role="main">
    


<article class="post">
  <header class="post-header">
    <h2 class="post-title">
      <a href="/istanbul-nyc/">istanbul / nyc</a>
    </h2>
  </header>
  <section class="post-excerpt">
    A good-but-not-great metric of how well you&apos;re testing your is code coverage. Basically it&apos;s how much of your code gets covered by your tests. There exist many tools to do this but we&apos;re going to use the most common in the JavaScript world: <a href="https://github.com/gotwarlost/istanbul">istanbul</a>.
    
  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <header class="post-header">
    <h2 class="post-title">
      <a href="/a-note-on-hot-module-reload/">A Note on Hot Module Reload</a>
    </h2>
  </header>
  <section class="post-excerpt">
    So webpack has a nifty ability to do what&apos;s called hot module reload (HMR.) If you&apos;ve ever used LiveReload&apos;s CSS injection, this will sound familiar. HMR will take your code, compile it on the fly, and then inject it into your live-running code. Pretty cool tech.
    
  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <header class="post-header">
    <h2 class="post-title">
      <a href="/data-in-react/">Data in React</a>
    </h2>
  </header>
  <section class="post-excerpt">
    So now we want to add a third page: a page where we can watch the trailer. This is going to be an application of what we know already.
    
  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <header class="post-header">
    <h2 class="post-title">
      <a href="/react-lifecycle-methods-and-ajax-with-react/">React Lifecycle Methods and AJAX with React</a>
    </h2>
  </header>
  <section class="post-excerpt">
    Due to the structuring of our app, we haven&apos;t had to use React lifecycle methods despite the fact they&apos;re fairly common to use and thus important to know. One of the most compelling reasons to use lifecycle methods is to do AJAX. Once a component gets mounted to the page then we want to be able request data from the server. First let&apos;s discuss the lifecycle of a React component.
    
  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <header class="post-header">
    <h2 class="post-title">
      <a href="/react-tools/">React Tools</a>
    </h2>
  </header>
  <section class="post-excerpt">
    So far we&apos;ve been using pretty old school debugging technology: console.logs and just dumping stuff out to the DOM. There is an easier way! <a href="https://github.com/facebook/react-devtools">React Dev Tools</a>! Grab it here for <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">Chrome</a> and <a href="https://addons.mozilla.org/en-US/firefox/addon/react-devtools/">Firefox</a>. In <em>theory</em> you can get the Chrome version working on Microsoft Edge, but good luck. If you&apos;re not using Chrome or Firefox, you&apos;re out of luck for now. They&apos;re talking about doing a standalone app but we&apos;ll see when that finally surfaces. I&apos;ll be talking about the Firefox version because that&apos;s the one I know the best but this should apply to Chrome just as well.
    
  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <header class="post-header">
    <h2 class="post-title">
      <a href="/redux/">redux</a>
    </h2>
  </header>
  <section class="post-excerpt">
    The next thing we want to do with our app is make the front page&apos;s search work so that when you type in a search query and hit enter it will automatically have searched for that on the Search page. Right now you have all the necessary tools to do that via state. You could just push the query term up to the ClientApp level and then pass that down to the Search and you&apos;d be done. And that&apos;s the way you <em>should</em> do it given how small our app is.
    
  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>





    
<nav class="pagination" role="navigation">
  
    <a class="newer-posts" href="/page/2/">&larr; Newer Posts</a>
  

  <span class="page-number">3 of 4</span>

  
    <a class="older-posts" href="/page/4/">Older Posts &rarr;</a>
  
</nav>

  </main>

  <footer class="site-footer clearfix">
    <p class="footer-description">
      &copy; Complete Intro to React
    </p>
    <p class="footer-published">
      joyfully published by <a href="https://github.com/reptar/reptar">reptar</a>
    </p>
  </footer>

  <script type="text/javascript" src="/js/main-c614ff7b24.js"></script>
</body>
</html>
